#!/bin/bash
RELAY_PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
RELAY_SERVICE_NAME="${RELAY_SERVICE_NAME:-port-relay}"

load_env() {
	if [[ ! -f "$RELAY_PROJECT_DIR/.env" ]]; then
		echo "Error: .env file not found in $RELAY_PROJECT_DIR"
		return 1
	fi
	source "$RELAY_PROJECT_DIR/.env"
	return 0
}

parse_relay_entries() {
	RELAY_ENTRIES=()
	for key in $(printf '%s\n' "${!RELAY_@}" | grep -E '^RELAY_[0-9]+$' | sort -V); do
		value="${!key}"
		IFS=';' read -r in_port out_port out_host protocol <<< "$value"
		protocol="${protocol:-TCP}"
		protocol="$(echo "$protocol" | tr '[:lower:]' '[:upper:]')"
		[[ "$protocol" != "TCP" && "$protocol" != "UDP" ]] && protocol="TCP"
		if [[ -n "$in_port" && -n "$out_port" && -n "$out_host" ]]; then
			RELAY_ENTRIES+=("$in_port:$out_port:$out_host:$protocol")
		fi
	done
}

check_duplicate_ports() {
	local seen=""
	for entry in "${RELAY_ENTRIES[@]}"; do
		IFS=':' read -r in_port _ _ protocol <<< "$entry"
		local key="${in_port}:${protocol}"
		if [[ "$seen" == *" $key "* ]]; then
			echo "Error: Duplicate incoming port $in_port ($protocol) in RELAY_* entries"
			return 1
		fi
		seen="$seen $key "
	done
	return 0
}

check_target() {
	local host="$1"
	local port="$2"
	local timeout="${3:-5}"
	local retries="${4:-3}"
	local attempt=1
	local run_timeout=""
	if command -v timeout >/dev/null 2>&1; then
		run_timeout() { timeout "$@"; }
	else
		run_timeout() { shift; "$@"; }
	fi
	while [[ $attempt -le $retries ]]; do
		if run_timeout "$timeout" /bin/bash -c "echo -n '' > /dev/tcp/$host/$port" 2>/dev/null; then
			return 0
		fi
		if command -v nc >/dev/null 2>&1; then
			if run_timeout "$((timeout + 2))" nc -4 -z -w "$timeout" "$host" "$port" 2>/dev/null; then
				return 0
			fi
		fi
		((attempt++)) || true
	done
	return 1
}

relay_service_stop() {
	systemctl stop "$RELAY_SERVICE_NAME" 2>/dev/null || true
}

relay_service_disable() {
	systemctl disable "$RELAY_SERVICE_NAME" 2>/dev/null || true
}

relay_conntrack_apply() {
	iptables -w -C INPUT -m conntrack --ctstate INVALID -j DROP 2>/dev/null || iptables -w -I INPUT 1 -m conntrack --ctstate INVALID -j DROP
	iptables -w -C OUTPUT -m conntrack --ctstate INVALID -j DROP 2>/dev/null || iptables -w -I OUTPUT 1 -m conntrack --ctstate INVALID -j DROP
	iptables -w -C FORWARD -m conntrack --ctstate INVALID -j DROP 2>/dev/null || iptables -w -I FORWARD 1 -m conntrack --ctstate INVALID -j DROP
}

relay_conntrack_remove() {
	iptables -D INPUT -m conntrack --ctstate INVALID -j DROP 2>/dev/null || true
	iptables -D OUTPUT -m conntrack --ctstate INVALID -j DROP 2>/dev/null || true
	iptables -D FORWARD -m conntrack --ctstate INVALID -j DROP 2>/dev/null || true
}

relay_firewall_apply() {
	for entry in "${RELAY_ENTRIES[@]}"; do
		IFS=':' read -r in_port _ _ protocol <<< "$entry"
		local proto
		proto="$(echo "$protocol" | tr '[:upper:]' '[:lower:]')"
		iptables -D INPUT -p "$proto" --dport "$in_port" -j ACCEPT 2>/dev/null || true
		iptables -A INPUT -p "$proto" --dport "$in_port" -j ACCEPT 2>/dev/null || true
	done
}

relay_firewall_remove() {
	for entry in "${RELAY_ENTRIES[@]}"; do
		IFS=':' read -r in_port _ _ protocol <<< "$entry"
		local proto
		proto="$(echo "$protocol" | tr '[:upper:]' '[:lower:]')"
		iptables -D INPUT -p "$proto" --dport "$in_port" -j ACCEPT 2>/dev/null || true
	done
}

resolve_host_to_ip() {
	local host="$1"
	[[ -z "$host" ]] && return 1
	if [[ "$host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
		echo "$host"
		return 0
	fi
	local ip
	ip=$(getent ahostsv4 "$host" 2>/dev/null | awk '/STREAM/ {print $1; exit}')
	[[ -z "$ip" ]] && ip=$(getent hosts "$host" 2>/dev/null | awk '{print $1; exit}')
	[[ -n "$ip" ]] && echo "$ip" || return 1
}

relay_udp_nat_apply() {
	local relay_ip="$1"
	[[ -z "$relay_ip" ]] && return 1
	for entry in "${RELAY_ENTRIES[@]}"; do
		IFS=':' read -r in_port out_port out_host protocol <<< "$entry"
		[[ "$protocol" != "UDP" ]] && continue
		local out_ip
		out_ip=$(resolve_host_to_ip "$out_host") || { echo "Error: cannot resolve '$out_host' to IP (required for iptables UDP NAT)"; return 1; }
		iptables -t nat -D PREROUTING -p udp --dport "$in_port" -j DNAT --to-destination "$out_ip:$out_port" 2>/dev/null || true
		iptables -t nat -A PREROUTING -p udp --dport "$in_port" -j DNAT --to-destination "$out_ip:$out_port"
		iptables -t nat -D POSTROUTING -p udp -d "$out_ip" --dport "$out_port" -j SNAT --to-source "$relay_ip" 2>/dev/null || true
		iptables -t nat -A POSTROUTING -p udp -d "$out_ip" --dport "$out_port" -j SNAT --to-source "$relay_ip"
	done
}

relay_udp_nat_remove() {
	local relay_ip
	relay_ip="$(ip route get 1.2.3.4 2>/dev/null | awk '{print $7; exit}')"
	[[ -z "$relay_ip" ]] && relay_ip="0.0.0.0"
	for entry in "${RELAY_ENTRIES[@]}"; do
		IFS=':' read -r in_port out_port out_host protocol <<< "$entry"
		[[ "$protocol" != "UDP" ]] && continue
		local out_ip
		out_ip=$(resolve_host_to_ip "$out_host") || continue
		iptables -t nat -D PREROUTING -p udp --dport "$in_port" -j DNAT --to-destination "$out_ip:$out_port" 2>/dev/null || true
		iptables -t nat -D POSTROUTING -p udp -d "$out_ip" --dport "$out_port" -j SNAT --to-source "$relay_ip" 2>/dev/null || true
	done
}
